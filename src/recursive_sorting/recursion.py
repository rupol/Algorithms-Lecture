import timeit
import functools


# write a function that prints every number from n to zero
# iterative approach
def print_numbers(n):
    for i in range(n, 0, -1):
        print(i)

# print_numbers(4)


# recursive approach
def print_num(n):  # O(1) * O(n) = O(n)
    print(n)

    # a base case (i.e. the code that tells us to stop running the function)
    if n == 0:
        return

    # recursive case (i.e. the case that takes us to the next subproblem)
    print_num(n-1)
    # return

# print_num(4)


def double_print_num(n):  # O(2^n)
    print(n)  # 2. prints 3; 4. prints 2; 6. prints 1; 8. prints 0

    if n == 0:
        return  # 9. pops double_print_num(0) off the stack

    # 3. pushes double_print_num(2) onto the stack; 5. pushes double_print_num(1) onto the stack; 7. pushes double_print_num(0) onto the stack
    double_print_num(n-1)
    double_print_num(n-1)  # 10. pushes double_print_num(1) onto the stack
    # return


# double_print_num(3)  # 1. pushes function onto stack


# Fibonacci Sequence - each number in the sequence is generated by taking the sum of the two previous numbers
# Fib(n) = Fib(n-1) + Fib(n-2)
# base case:
# at n = 0, Fib(0) = 0
# at n = 1, Fib(1) = 1
# this is obviously recursion!

# def memoize(func):
#     cache = dict()

#     def memoized_func(*args):
#         if args in cache:
#             return cache[args]
#         result = func(*args)
#         cache[args] = result
#         return result

#     return memoized_func


@functools.lru_cache(maxsize=128)
def fib(n):
    # base case (doesn't go into recursion)
    if n == 0:
        return 0
    if n == 1:
        return 1
    # recursive case
    result = fib(n-1) + fib(n-2)
    return result


# print(fib(1))
# print(fib(2))
# print(fib(3))
# print(fib(4))
# print(fib(5))
# print(fib(6))
# print(fib(7))
# print(fib(8))
print(fib(35))
print(timeit.timeit('fib(35)', globals=globals(), number=1))
# print(memoize(fib(35)))
# print(timeit.timeit('memoize(fib(35))', globals=globals(), number=1))
